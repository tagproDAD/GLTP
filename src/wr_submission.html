<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>TagPro Replay Parser</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; }
    input, button { padding: 10px; margin: 5px; }
    pre { background: #f5f5f5; padding: 20px; white-space: pre-wrap; }
  </style>
</head>
<body>
  <h1>TagPro Replay Parser</h1>
  <input id="uuidInput" placeholder="Enter UUID or full replay URL">
  <button onclick="parseReplay()">Parse Replay</button>
  <pre id="output"></pre>

  <script>
  //async function fetchReplay(uuid) {
  //  const response = await fetch(`https://your-vercel-project.vercel.app/api/fetchReplay?uuid=${uuid}`);
  //  if (!response.ok) {
  //    throw new Error("Failed to fetch replay data");
  //  }
  //  return await response.json();
  //  }
  function extractUUID(input) {
    const uuidRegex = /[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}/i;
    const match = input.match(uuidRegex);
    return match ? match[0] : null;
    }


    async function fetchReplay(uuid) {
    const proxyUrl = "https://corsproxy.io/?";
    const metadataResponse = await fetch(`${proxyUrl}https://tagpro.koalabeast.com/replays/data?uuid=${uuid}`);
    if (!metadataResponse.ok) throw new Error("Failed to fetch metadata, make sure you're using the UUID");

    const metadata = await metadataResponse.json();
    if (!metadata.games || metadata.games.length !== 1) {
      throw new Error("Unexpected replay format");
    }

    const gameId = metadata.games[0].id;
    const gameResponse = await fetch(`${proxyUrl}https://tagpro.koalabeast.com/replays/gameFile?gameId=${gameId}`);
    if (!gameResponse.ok) throw new Error("Failed to fetch replay data");

    const text = await gameResponse.text();
    const lines = text.trim().split("\n").map(line => JSON.parse(line));
    return lines;
  }


    function formatMilliseconds(milliseconds) {
      const minutes = Math.floor(milliseconds / 60000);
      const seconds = (milliseconds % 60000) / 1000;
      return `${minutes}:${seconds.toFixed(3).padStart(6, '0')}`;
    }

    async function fetchMaps() {
      const digits = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";

      function injectMapIdIntoPreset(preset, mapId) {
        let n = parseInt(mapId, 10);
        let enc = n === 0 ? digits[0] : "";

        while (n > 0) {
          const r = n % 52;
          enc = digits[r] + enc;
          n = Math.floor(n / 52);
        }

        const inner = "f" + enc;
        const inj = "M" + digits[inner.length] + inner;
        const pos = preset.indexOf("M");

        if (pos === -1) return preset;

        const oldLen = digits.indexOf(preset.charAt(pos + 1));
        return preset.slice(0, pos) + inj + preset.slice(pos + 2 + oldLen);
      }

      const response = await fetch("https://docs.google.com/spreadsheets/d/1OnuTCekHKCD91W39jXBG4uveTCCyMxf9Ofead43MMCU/export?format=csv&gid=1775606307");
      if (!response.ok) throw new Error("Failed to fetch map data");

      const csvText = await response.text();
      const rows = csvText.trim().split("\n").map(row => row.split(","));
      const headers = rows.shift();

      const get = (row, header) => row[headers.indexOf(header)]?.trim();

      const rawMaps = rows.map(row => ({
        name: get(row, "Map / Player"),
        preset: get(row, "Group Preset"),
        difficulty: get(row, "Final Rating"),
        fun: get(row, "Final Fun \nRating"),
        category: get(row, "Category"),
        map_id: get(row, "Map ID"),
        equivalent_map_ids: get(row, "Pseudo \nMap ID")?.split(",") || [],
        caps_to_win: get(row, "Num\nof caps"),
        allow_blue_caps: get(row, "Allow Blue Caps") === "TRUE",
        balls_req: get(row, "Min\nBalls \nRec"),
        max_balls_rec: get(row, "Max\nBalls\nRec"),
      }));

      const illegalMaps = rawMaps.filter(m =>
        !m.preset ||
        !m.map_id ||
        injectMapIdIntoPreset(m.preset, m.map_id) !== m.preset
      );

      const illegalMapIds = new Set(illegalMaps.map(m => m.map_id));

      return rawMaps.filter(m => !illegalMapIds.has(m.map_id));
    }



    function cleanMapName(name) {
      const parts = name.rsplit(" by ", 1);
      return parts.length === 2 && parts[1].length <= 100 ? parts[0] : name;
    }

    function getDetails(replay, maps) {
      if (replay[0][1] !== "recorder-metadata" || replay[2][1] !== "map" || replay[3][1] !== "clientInfo") {
        throw new Error("Invalid replay format");
      }

      const metadata = replay[0][2];
      const mapData = replay[2][2];
      const mapfile = replay[3][2]?.mapfile;
      const mapId = mapfile ? mapfile.split("/")[1] : null;

      const players = {};
      metadata.players.forEach(player => {
        players[player.id] = {
          name: player.displayName,
          user_id: player.userId,
          is_red: player.team === 1
        };
      });

      const firstTimerTs = replay.find(r => r[1] === 'time' && r[2]?.state === 1)?.[0] ?? 0;

      let recordTime = null;
      let cappingUserName = null;
      let cappingUserId = null;
      let cappingPlayerQuote = null;

      for (const [ts, type, data] of replay) {
        if (type !== 'p') continue;

        for (const playerData of data) {
          if (!playerData["s-captures"] || playerData["s-captures"] < 1) continue;

          const cappingPlayer = players[playerData.id];
          if (!cappingPlayer) continue;

          recordTime = ts - firstTimerTs;
          cappingUserName = cappingPlayer.name;
          cappingUserId = cappingPlayer.user_id;

          const playerChats = replay.filter(r => r[1] === 'chat' && r[2].from === playerData.id);
          cappingPlayerQuote = playerChats.length ? playerChats[playerChats.length - 1][2].message : null;

          break;
        }
        if (recordTime !== null) break;
      }


      let matchedMap = maps.find(m => m.map_id === mapId);
      if (!matchedMap) {
        matchedMap = maps.find(m => m.equivalent_map_ids.includes(String(mapId)));
      }

      let capsToWin = 1;
      let allowBlueCaps = false;
      let effectiveMapId = mapId;

      if (matchedMap) {
        const capsRaw = matchedMap.caps_to_win;
        capsToWin = capsRaw === "pups" ? Infinity : parseInt(capsRaw || "1", 10);
        allowBlueCaps = !!matchedMap.allow_blue_caps;
        effectiveMapId = matchedMap.map_id;
      }

      return {
        map_name: mapData.info.name,
        map_author: mapData.info.author,
        players: Object.values(players),
        capping_player: cappingUserName,
        capping_player_user_id: cappingUserId,
        record_time: recordTime !== null ? formatMilliseconds(recordTime) : null,
        is_solo: Object.keys(players).length === 1,
        timestamp: metadata.started,
        uuid: metadata.uuid,
        capping_player_quote: cappingPlayerQuote,
        caps_to_win: capsToWin,
        allow_blue_caps: allowBlueCaps,
        effective_map_id: effectiveMapId
      };
    }


    async function parseReplay() {
      const uuid = document.getElementById("uuidInput").value.trim();
      const output = document.getElementById("output");
      output.textContent = "Loading...";

      try {
        const uuidMatch = input.match(/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/i);
        const uuid = uuidMatch ? uuidMatch[0] : input;
        const replay = await fetchReplay(uuid);
        const maps = await fetchMaps();
        const details = getDetails(replay, maps);
        output.textContent = JSON.stringify(details, null, 2);
      } catch (error) {
        output.textContent = "Error: " + error.message;
        console.error(error);
      }
    }
  </script>
</body>
</html>
